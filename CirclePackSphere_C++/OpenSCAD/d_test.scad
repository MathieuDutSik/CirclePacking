// Joined Rhombicuboctahedron

// base coordinates
// source:  http://dmccooey.com/polyhedra/JoinedRhombicuboctahedron.txt
// generated by  http://kitwallace.co.uk/3d/solid-to-scad.xq

include <OpenSC_4R0_5R3_1>


// construct cylinders along edges spheres at vertices and optional faces

// Edge radius
// Edge_R=2.5;
Edge_R=0.075;
//Vertex radius
//Vertex_R=2.;
Vertex_R=Edge_R;
// scale
Scale=1;
// Generate the edges
Edge = 1;
// Generate the plane faces
Face = 0;
// generate the vertices
Vertex=1;
// no of sides of wire
Edge_sides=20;
// no of sides of vertex
Vertex_sides=20;

bary=vsum(points)/len(points);

ms=10/10;
mmm=[[ms,0,0],[0,1,0],[0,0,1]];
  mmm=[[1,0,0],[0,ms,0],[0,0,1]];
/* mmm=[[1,0,0],[0,1,0],[0,0,ms]]; /* */

arg=35.64; /*9.+2*22.5+1*36; */


arg2=3*30;

arg3=-0;

turn=[[cos(arg),-sin(arg),0],[sin(arg),cos(arg),0],[0,0,1]];

turn2=[[0,cos(arg2),-sin(arg2)],[0,sin(arg2),cos(arg2)],[1,0,0]];
turn3=[[cos(arg3),0,-sin(arg3)],[sin(arg3),0,cos(arg3)],[0,1,0]];

points1 = [for(i=[0:len(points)-1]) mmm*turn3*turn2*turn *(points[i]-bary)];

//insert
module polytope(){
spoints = Scale * points1;

if (Edge) make_edges(spoints,edges,Edge_R,$fn=Edge_sides);
if (Vertex) make_vertices(spoints,Vertex_R,$fn=Vertex_sides);
if (Face) polyhedron(spoints,faces);
}

// ruler(10);

// functions for the construction of polyhedra
// chris wallace
// see http://kitwallace.tumblr.com/tagged/polyhedra for info

module locate(p1, p2) {
   assign(p = p2 - p1)
   assign(distance = norm(p)) {
      translate(p1)
//rotation of XoY plane by the Z axis with the angle of the [p1 p2] line projection with the X axis on the XoY plane
      rotate([0, 0, atan2(p[1], p[0])]) //rotation
//rotation of ZoX plane by the y axis with the angle given by the z coordinate and the sqrt(x^2 + y^2)) point in the XoY plan
      rotate([0, atan2(sqrt(pow(p[0], 2)+pow(p[1], 2)),p[2]), 0])
      children();
  }
}

function m_translate(v) = [ [1, 0, 0, 0],
                            [0, 1, 0, 0],
                            [0, 0, 1, 0],
                            [v.x, v.y, v.z, 1  ] ];

function m_rotate(v) =  [ [1,  0,         0,        0],
                          [0,  cos(v.x),  sin(v.x), 0],
                          [0, -sin(v.x),  cos(v.x), 0],
                          [0,  0,         0,        1] ]
                      * [ [ cos(v.y), 0,  -sin(v.y), 0],
                          [0,         1,  0,        0],
                          [ sin(v.y), 0,  cos(v.y), 0],
                          [0,         0,  0,        1] ]
                      * [ [ cos(v.z),  sin(v.z), 0, 0],
                          [-sin(v.z),  cos(v.z), 0, 0],
                          [ 0,         0,        1, 0],
                          [ 0,         0,        0, 1] ];

function vec3(v) = [v.x, v.y, v.z];
function transform(v, m)  = vec3([v.x, v.y, v.z, 1] * m);

function orientate(p0, p) =
                       m_rotate([0, atan2(sqrt(pow(p[0], 2) + pow(p[1], 2)), p[2]), 0])
                     * m_rotate([0, 0, atan2(p[1], p[0])])
                     * m_translate(p0);

function orientate_r(p0, p) =
                      m_translate(-p0)
                      * m_rotate([0, 0, -atan2(p[1], p[0])])
                      * m_rotate([0, -atan2(sqrt(pow(p[0], 2) + pow(p[1], 2)), p[2]), 0]);

function transform_points(list, matrix, i = 0) =
    i < len(list)
       ? concat([ transform(list[i], matrix) ], transform_points(list, matrix, i + 1))
       : [];

function as_points(ids,points,i=0) =
     i < len(ids)
        ?  concat([points[ids[i]]], as_points(ids,points,i+1))
        : [];

function normal_r(face) =
     cross(face[1]-face[0],face[2]-face[0]);

function normal(face) =
     - normal_r(face) / norm(normal_r(face));

function centre(points) =
      vsum(points) / len(points);

function vsum(points,i=0) =
      i < len(points)
        ?  (points[i] + vsum(points,i+1))
        :  [0,0,0];


function vsub(points,v,i=0) =
      i < len(points)
        ?  concat([points[i] - v], vsub(points,v,i+1))
        :  [];

function project(pts,i=0) =
     i < len(pts)
        ? concat([[pts[i][0],pts[i][1]]], project(pts,i+1))
        : [];

function select_nsided_faces(faces,nsides,i=0) =
     i < len(faces)
         ?  len(faces[i]) == nsides || nsides == 0
             ? concat([faces[i]],  select_nsided_faces(faces,nsides,i+1))
             : select_nsided_faces(faces,nsides,i+1)
         : [];
function longest_edge(face,max=-1,i=0) =
       i < len(face)
          ?  norm(face[i] - face[(i+1)% len(face)]) > max
             ?  longest_edge(face, norm(face[i] - face[(i+1)% len(face)]),i+1)
             :  longest_edge(face, max,i+1)
          : max ;

module make_edge(edge, points, r) {
    assign(p0 = points[edge[0]], p1 = points[edge[1]])
     locate(p0,p1)
       cylinder(r=r, h=norm(p1-p0));
}

module make_edges(points, edges, r) {
   for (i =[0:len(edges)-1])
      make_edge(edges[i],points, r);
}

module make_vertices(points,r) {
   for (i = [0:len(points)-1])
      translate(points[i]) sphere(r);
}

module face_prism (face,prism_base_ratio,prism_scale,prism_height_ratio) {
    assign (n = normal(face), c= centre(face))
    assign (m = orientate_r(c,n))
    assign (tpts =  prism_base_ratio * transform_points(face,m))
    assign (max_length = longest_edge(face))
    assign (xy = project(tpts))
      linear_extrude(height=prism_height_ratio * max_length, scale=prism_scale)
          polygon(points=xy);
}

module face_prisms_in(faces,points,prism_base_ratio,prism_scale,prism_height_ratio) {
    for (i=[0:len(faces) - 1])
       assign (f = as_points(faces[i],points))
       assign (n = normal(f), c = centre(f))
       locate(c,c+n)
          translate([0,0,eps])
               mirror() rotate([0,180,0])
                   face_prism(f,prism_base_ratio,prism_scale,prism_height_ratio);
}

module face_prisms_out(faces,points,prism_base_ratio,prism_scale,prism_height_ratio) {
    for (i=[0:len(faces) - 1])
       assign (f = as_points(faces[i],points))
       assign (n = normal(f), c = centre(f))
       locate(c,c+n)
          face_prism(f,prism_base_ratio,prism_scale,prism_height_ratio);
}

module ruler(n) {
   for (i=[0:n-1])
       translate([(i-n/2 +0.5)* 10,0,0]) cube([9.8,5,2], center=true);
}


polytope();
